<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M3T: M3T: A Multi-body Multi-modality Multi-camera 3D Tracker</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M3T
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">M3T: A Multi-body Multi-modality Multi-camera 3D Tracker </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_readme"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Publication</h1>
<p>Closing the Loop: 3D Object Tracking for Advanced Robotic Manipulation <br  />
 Manuel Stoiber <br  />
 Dissertation submitted to the Technical University of Munich</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>Tracking objects and kinematic structures and determining their poses and configurations is an essential task in computer vision. Its application ranges from augmented reality to robotic perception. Given 3D meshes and kinematic information, the goal is to robustly estimate both the rotation and translation of each body. The <em>M3T</em> library is able to consider images from multiple depth and color cameras. It allows to fuse information from depth, region, and texture modalities to simultaneously predict the pose and configuration of multiple multi-body objects. <em>M3T</em> is able to consider unknown occlusions using depth camera measurements or model known occlusions using depth and silhouette renderers. The algorithm is highly efficient and is able to provide results in real time, even for complex kinematic structures. To support a wide range of kinematic structures, object characteristics, and camera configurations, the overall framework is very modular and allows a flexible combination of different components such as cameras, links, constraints, modalities, viewers, detectors, refiners, publishers, and subscribers.</p>
<div class="image">
<img src="title.png" alt=""/>
<div class="caption">
title</div></div>
    <h1><a class="anchor" id="autotoc_md3"></a>
Content</h1>
<p>The repository is organized in the following folders:</p><ul>
<li><code>include/</code>: header files of the <em>M3T</em> library</li>
<li><code>src/</code>: source files of the <em>M3T</em> library</li>
<li><code>third_party/</code>: external header-only libraries</li>
<li><code>test/</code>: unit tests</li>
<li><code>data/</code>: data that is required for examples and unit tests</li>
<li><code>examples/</code>: example files for tracking as well as for evaluation on different datasets</li>
<li><code>doc/</code>: files for documentation</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Build</h1>
<p>Use <a href="https://cmake.org/">CMake</a> to build the library from source. The following dependencies are required: <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen 3</a>, <a href="http://glew.sourceforge.net/">GLEW</a>, <a href="https://www.glfw.org/">GLFW 3</a>, and <a href="https://opencv.org/">OpenCV 4</a>. In addition, unit tests are implemented using <a href="https://github.com/google/googletest">gtest</a>, while images from an Azure Kinect or RealSense camera can be streamed using the <a href="https://github.com/microsoft/Azure-Kinect-Sensor-SDK">K4A</a> and <a href="https://github.com/IntelRealSense/librealsense">realsense2</a> libraries. All three libraries are optional and can be disabled using the <em>CMake</em> flags <code>USE_GTEST</code>, <code>USE_AZURE_KINECT</code>, and <code>USE_REALSENSE</code>. If <a href="https://opencv.org/">OpenCV 4</a> is installed with <a href="https://developer.nvidia.com/cuda-downloads">CUDA</a>, feature detectors used in the texture modality are able to utilize the GPU. If <em>CMake</em> finds <a href="https://www.openmp.org/">OpenMP</a>, the code is compiled using multithreading and vectorization for some functions. Finally, the documentation is built if <a href="https://www.doxygen.nl/index.html">Doxygen</a> with <em>dot</em> is detected. Note that links to pages or classes that are embedded in this readme only work in the generated documentation. After a correct build, it should be possible to successfully execute all tests in <code>./gtest_run</code>. For maximum performance, ensure that the library is created in <code>Release</code> mode, and, for example, use <code>-DCMAKE_BUILD_TYPE=Release</code>.</p>
<p>Installation details</p><ol type="1">
<li>Eigen3</li>
</ol>
<p>Install Eigen3 (Ubuntu)</p>
<p>Installing Eigen3 on Ubuntu is quite straightforward. Note that you will be prompted for your password upon using sudo. Type: </p><pre class="fragment">sudo apt install libeigen3-dev
</pre><p> Install Eigen3 (Windows)</p>
<p>Download the desired release from <a href="http://eigen.tuxfamily.org">http://eigen.tuxfamily.org</a>. Unzip in the location of your choice, preferrably at C:\ or C:\Program files for better discoverability by CMake find-modules (remember to extract the inner folder and rename it to Eigen3 or Eigen).</p>
<ol type="1">
<li><p class="startli">Glew, glfw3</p>
<p class="startli">Windows: open cmd</p>
<p class="startli">git clone <a href="https://github.com/microsoft/vcpkg">https://github.com/microsoft/vcpkg</a> .\vcpkg\bootstrap-vcpkg.bat .\vcpkg\vcpkg install glfw3:x64-windows glew:x64-windows</p>
<p class="startli">CmakeList.txt: list(APPEND CMAKE_PREFIX_PATH "C:/vcpkg/packages/glew_x64-windows") list(APPEND CMAKE_PREFIX_PATH "C:/vcpkg/packages/glfw3_x64-windows")</p>
</li>
<li>OpenCV4</li>
</ol>
<p><a href="https://cv-tricks.com/how-to/installation-of-opencv-4-1-0-in-windows-10-from-source/">https://cv-tricks.com/how-to/installation-of-opencv-4-1-0-in-windows-10-from-source/</a></p>
<p>CmakeList.txt: set (OpenCV_DIR C:/opencv/build)</p>
<ol type="1">
<li><p class="startli">Azure Kinect</p>
<p class="startli">Windows:</p>
<p class="startli">cd C:\ git clone <a href="https://github.com/microsoft/Azure-Kinect-Sensor-SDK.git">https://github.com/microsoft/Azure-Kinect-Sensor-SDK.git</a> cd Azure-Kinect-Sensor-SDK git checkout -b v1.4.1 refs/tags/v1.4.1 mkdir build &amp;&amp; cd build cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_INSTALL_PREFIX="C:/Program Files/K4A" cmake &ndash;build . &ndash;config Release cmake &ndash;build . &ndash;target install &ndash;config Release</p>
</li>
<li><p class="startli">googletest</p>
<p class="startli">Windows:</p>
<p class="startli">git clone from <a href="https://github.com/google/googletest">https://github.com/google/googletest</a> cmake .. CmakeList.txt: set (GTEST_LIBRARY C:/googletest/build/lib/Release/gtest.lib) set (GTEST_MAIN_LIBRARY C:/googletest/build/lib/Release/gtest_main.lib) set (GTEST_INCLUDE_DIR C:/googletest/googletest/include)</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md5"></a>
Algorithm</h1>
<p>In the following, the tracking algorithm is described in detail. For this, we introduce the overall process executed by the tracker, describe the used components, and explain how they have to be configured.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Tracker Process</h2>
<p>The tracking process is coordinated by the <code>Tracker</code> object. Usually, only a single tracker exists that references all relevant components. Using the method <code>RunTrackerProcess</code>, the tracker executes the main methods of different components in the correct order. It considers the state of individual kinematic structures represented by <code>Optimizer</code> objects. In general, they can be in the states <em>detecting</em>, <em>starting</em>, and <em>tracking</em>. Also, kinematic structures may be idle. States can be influenced by the user with the methods <code>StartTracking</code>, <code>StopTracking</code>, and <code>ExecuteDetection</code>. Each method allows to specify names of optimizers to affect the respective kinematic structures. In addition, it is possible to change the state of all kinematic structures by pressing the <code>T</code> key to start tracking, the <code>S</code> key to stop tracking, the <code>D</code> key to start the detection, and the <code>X</code> key to start the detection and directly start tracking. With <code>QuitTrackerProcess</code> or the <code>Q</code> key, one can quit the tracking process.</p>
<p>Each iteration of the tracker process starts with an update of all <code>Camera</code> and <code>Subscriber</code> objects. Subsequently, given that <code>Subscriber</code> objects are able to change the poses of individual <code>Link</code> and <code>Body</code> objects, poses are updated to be consistent. After that, <em>Detecting</em>, <em>Starting</em>, and <em>Tracking Steps</em> are executed. Each step only considers objects associated with kinematic structures in the corresponding state. Finally, once individual steps have been finished, <code>Publishers</code> and <code>Viewers</code> are updated. The process then starts from the beginning. An overview of the major steps in the tracker process is shown in the following algorithm: </p><pre>
<b>Tracker Process:</b>
 1: <b>while</b> run tracker process <b>do</b>
 2:     Update all Camera objects
 3:     Update all Subscriber objects
 4:     Calculate consistent Link and Body poses
 5:     Run <em>Detecting Step</em> (for objects associated with the state <em>detecting</em>)
 6:     Run <em>Starting Step</em> (for objects associated with the state <em>starting</em>)
 7:     Run <em>Tracking Step</em> (for objects associated with the state <em>tracking</em>)
 8:     Update all Publisher objects
 9:     Update all Viewer objects
10: <b>end while</b>
</pre><p>For the <em>Detecting Step</em>, first, all <code>Detector</code> objects associated with the state <em>detecting</em> are run. If the detection is successful, the <code>Detector</code> updates the poses of all <code>Link</code> and <code>Body</code> objects in the kinematic structure. Subsequently, for all kinematic structures that were successfully detected, associated <code>Refiner</code> objects improve predictions. Finally, if desired, successfully detected structures move to the state <em>starting</em>. An overview of the <em>Detecting Step</em> is shown in the following algorithm:</p>
<pre>
<b>Detecting Step:</b>
 1: Run Detector objects
 2: Run Refiner objects for successful detections
 3: If desired, move to state <em>starting</em> for successful detections
</pre><p>In the <em>Starting Step</em>, first, all <code>Renderer</code> objects that are required by <code>Modality</code> objects are executed. After that, each <code>Modality</code> is started. This operation, for example, initializes internal color histograms of <code>RegionModality</code> objects. Subsequently, the <em>Starting Step</em> also performs the initialization of shared <code>ColorHistograms</code> objects. Finally, each kinematic structure automatically moves into the state <em>tracking</em>. An overview of the individual steps is shown in the following algorithm:</p>
<pre>
<b>Starting Step:</b>
 1: Run Renderer objects required for the starting of Modality objects
 2: Start Modality objects
 3: Initialize ColorHistograms objects
 4: Move to state <em>tracking</em>
</pre><p>Finally, the <em>Tracking Step</em> considers the estimation of poses by iteratively computing correspondences and pose updates. To calculate correspondences for <code>Modality</code> objects, it first runs required <code>Renderer</code> objects. Typical examples are <code>SilhouetteRenderer</code> objects that are used to validate individual contour or surface points. Afterwards, correspondences are calculated. This is typically followed by two update iterations. In each iteration, gradient vectors and Hessian matrices are calculated for all <code>Modality</code> objects. Afterwards, kinematic structures are updated. <code>Optimizer</code> objects thereby compute gradient vectors and Hessian matrices of <code>SoftConstraint</code> objects, calculate the Jacobian of each <code>Link</code> object, compute Jacobians and residuals of <code>Constraint</code> objects, and, finally, assemble everything in a single linear system of equations. <code>Optimizer</code> objects then solve the equations and update the poses of all <code>Link</code> and <code>Body</code> objects. Subsequently, the iterations are repeated. Finally, after the last iteration, required <code>Renderer</code> objects are run, and <code>Modality</code> and <code>ColorHistograms</code> objects are updated. An overview of the individual steps is shown in the following algorithm:</p>
<pre>
<b>Tracking Step:</b>
 1: <b>for</b> n_corr_iterations <b>do</b>
 2:     Run Renderer objects required for the calculation of correspondences
 3:     Calculate correspondences for Modality objects
 4:     <b>for</b> n_update_iterations <b>do</b>
 5:         Calculate gradients and Hessians for Modality objects
 6:         <b>for</b> all Optimizer objects <b>do</b>
 7:             Calculate gradients and Hessians of referenced SoftConstraint objects
 8:             Calculate Jacobians of referenced Link objects
 9:             Calculate Jacobians and residuals of referenced Cosntraint objects
10:             Assemble and solve linear system of equations
11:             Update poses of referenced Link and Body objects
12:         <b>end for</b>
13:     <b>end for</b>
14: <b>end for</b>
15: Run Renderer objects for the update of Modality objects
16: Update Modality objects
17: Update ColorHistograms objects
</pre><p>#</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Main Components</h1>
<p>The library consists of multiple components that provide specific functionality and data. They allow a flexible configuration of the tracker. The following main components exist (note that links only work in the Doxygen documentation):</p><ul>
<li><b>Camera:</b> Specifies the abstract method <code>UpdateImage</code> to fetch images and provides those images to other components. In addition, it stores intrinsics and defines the camera's pose relative to the world coordinate frame. In general, one differentiates between <code>ColorCamera</code> and <code>DepthCamera</code> classes. Currently, different implementations exist. To load images from disk, the <a href="classm3t_1_1LoaderColorCamera.html">LoaderColorCamera</a> and <a href="classm3t_1_1LoaderDepthCamera.html">LoaderDepthCamera</a> classes are used. To stream data from a physical Azure Kinect or RealSense camera, the <a href="classm3t_1_1AzureKinectColorCamera.html">AzureKinectColorCamera</a>, <a href="classm3t_1_1AzureKinectDepthCamera.html">AzureKinectDepthCamera</a>, <a href="classm3t_1_1RealSenseColorCamera.html">RealSenseColorCamera</a>, and <a href="classm3t_1_1RealSenseDepthCamera.html">RealSenseDepthCamera</a> classes are used.</li>
<li><b>Body:</b> Holds the pose of a rigid body relative to the world coordinate frame and stores the body's mesh geometry. It also specifies values for region and body IDs that are used in the rendering of silhouette images. It is implemented in the <a href="classm3t_1_1Body.html">Body</a> class.</li>
<li><b>RendererGeometry:</b> Stores geometric information from referenced <code>Body</code> objects on the GPU and provides everything required for rendering. It is implemented in the <a href="classm3t_1_1RendererGeometry.html">RendererGeometry</a> class.</li>
<li><b>Renderer:</b> Creates a rendering based on the geometry stored in a referenced <code>RendererGeometry</code> object, the pose of corresponding <code>Body</code> objects, the view of the renderer on the scene defined by intrinsics, and the renderer's pose relative to the world coordinate frame. For tracking, intrinsics and the pose are typically inferred from the values of a corresponding <code>Camera</code> object. Both <code>FullRenderers</code>, which render an image according to intrinsics, and <code>FocusedRenderers</code>, which focus on referenced bodies and render an image with a defined size that is scaled and cropped to only include the referenced bodies, exist. For occlusion handling, region checking, and silhouette checking, <code>FocusedRenderer</code> objects are used. Based on the data in the <code>RendererGeometry</code>, different bodies can be considered. Depth images are obtained by the <a href="classm3t_1_1FullBasicDepthRenderer.html">FullBasicDepthRenderer</a> and <a href="classm3t_1_1FocusedBasicDepthRenderer.html">FocusedBasicDepthRenderer</a> classes. Silhouette images that contain either region or body IDs from <code>Body</code> objects can be created using the <a href="classm3t_1_1FullSilhouetteRenderer.html">FullSilhouetteRenderer</a> and <a href="classm3t_1_1FocusedSilhouetteRenderer.html">FocusedSilhouetteRenderer</a> classes. Normal images that encode the surface normal vector in pixel colors can be created using the <a href="classm3t_1_1FullNormalRenderer.html">FullNormalRenderer</a> and <a href="classm3t_1_1FocusedNormalRenderer.html">FocusedNormalRenderer</a> classes.</li>
<li><b>Model:</b> Precomputes geometric information from a referenced <code>Body</code> and stores the created data. During the generation, geometries from external <code>Body</code> objects can also be considered. This can, for example, be used to consider known occlusions before tracking. Two versions exist: a <a href="classm3t_1_1RegionModel.html">RegionModel</a> that samples contour points and a <a href="classm3t_1_1DepthModel.html">DepthModel</a> that computes surface points. They are used for <code>RegionModality</code> and <code>DepthModality</code> objects, respectively. Modalities that consider the same geometry can use the same model.</li>
<li><b>ColorHistograms:</b> Computes and holds color histograms for the foreground and background. Typically, the object is incorporated in the <code>RegionModality</code>. However, if histograms should be shared, <code>ColorHistograms</code> can also be defined separately and referenced by multiple modalities. It is implemented in the <a href="classm3t_1_1ColorHistograms.html">ColorHistograms</a> class.</li>
<li><b>Modality:</b> Considers information from a <code>Camera</code> and <code>Body</code> to calculate the gradient vector and Hessian matrix used for Newton optimization. Currently, three <code>Modality</code> classes exist: a <a href="classm3t_1_1RegionModality.html">RegionModality</a> that sparsely considers region information and requires a <code>ColorCamera</code>, <code>Body</code>, and <code>RegionModel</code>, a <a href="classm3t_1_1DepthModality.html">DepthModality</a> that implements an ICP-like depth approach that considers data from a <code>DepthCamera</code>, <code>Body</code>, and <code>DepthModel</code>, and a <a href="classm3t_1_1TextureModality.html">TextureModality</a> that uses keypoint features and requires information from a <code>ColorCamera</code>, <code>Body</code>, and <code>SilhouetteRenderer</code>. Both the <code>RegionModality</code> and <code>TextureModality</code> allow to reference an additional <code>DepthCamera</code> that is close to the <code>ColorCamera</code> to recognize unknown occlusions. To model known occlusions, modalities allow referencing a <code>FocusedDepthRenderer</code>. Finally, for the validation of contour points and surface points, <code>RegionModality</code> and <code>DepthModality</code> objects use a <code>SilhouetteRenderer</code>. Also, <code>RegionModality</code> objects are able to reference external <code>ColorHistograms</code>.</li>
<li><b>Link:</b> Defines the location of a joint reference frame relative to the reference frame of the <a href="classm3t_1_1Link.html">Link</a> and its parent. For the joint, rotational and translational motion along defined coordinate axes is allowed. To build a tree-like kinematic structure, a <code>Link</code> is able to reference multiple <code>Link</code> objects as children. In general, <code>Link</code> objects contain all <code>Modality</code> objects that correspond to a single referenced <code>Body</code>. If a <code>Body</code> is configured, the reference frame of the <code>Link</code> is equal to that of the <code>Body</code>. Also, it is possible to create virtual <code>Link</code> objects without referenced <code>Body</code> or <code>Modality</code> objects to allow the definition of kinematics that do not feature visual information.</li>
<li><b>Constraint:</b> Takes two <code>Link</code> objects and defines the location of joint reference frames relative to corresponding link frames. Rotational and translational motion between the two joint frames is constrained for user-defined coordinate axes. It is implemented in the <a href="classm3t_1_1Constraint.html">Constraint</a> class.</li>
<li><b>SoftConstraint:</b> Like the <code>Constraint</code>, it takes two <code>Link</code> objects and defines the location of joint reference frames relative to corresponding link frames. Also, rotational and translational motion between the two joint frames is again constrained for user-defined coordinate axes. However, in contrast to the <code>Constraint</code> class, a standard deviation and a maximum distance for which the constraint remains inactive can be defined. It is implemented in the <a href="classm3t_1_1SoftConstraint.html">SoftConstraint</a> class.</li>
<li><b>Optimizer:</b> References a single <code>Link</code> at the root of a kinematic structure and multiple corresponding <code>Constraint</code> and <code>SoftConstraint</code> objects. It computes Jacobian matrices for all <code>Link</code> objects and uses them to project gradient vectors and Hessian matrices from <code>Modality</code> and <code>SoftConstraint</code> objects to the full gradient and Hessian required for Newton optimization. In addition, an <code>Optimizer</code> projects Jacobians and residuals from <code>Constraint</code> objects into the full system of linear equations. After a single Newton step, it updates the pose of all <code>Link</code> and <code>Body</code> objects in the kinematic structure. It is implemented in the <a href="classm3t_1_1Optimizer.html">Optimizer</a> class.</li>
<li><b>Detector:</b> Depending on the implementation, a <code>Detector</code> is able to reference multiple <code>Optimizer</code> objects. Based on the detected pose of the root <code>Link</code>, it updates the pose of all corresponding <code>Link</code> and <code>Body</code> objects in the kinematic structure. Two detectors are implemented: a <a href="classm3t_1_1StaticDetector.html">StaticDetector</a> that assigns a predefined pose and a <a href="classm3t_1_1ManualDetector.html">ManualDetector</a> that allows a user to define four points in a color image to infer the pose.</li>
<li><b>Viewer:</b> Is used to visualize the current pose estimate. While <a href="classm3t_1_1ImageColorViewer.html">ImageColorViewer</a> and <a href="classm3t_1_1ImageDepthViewer.html">ImageDepthViewer</a> classes simply visualize images from referenced <code>ColorCamera</code> and <code>DepthCamera</code> objects, <a href="classm3t_1_1NormalColorViewer.html">NormalColorViewer</a> and <a href="classm3t_1_1NormalDepthViewer.html">NormalDepthViewer</a> classes overlay camera images with normal renderings that are based on the data from a referenced <code>RendererGeometry</code> object.</li>
<li><b>Publisher:</b> Is used to communicate data to an external source. It features the abstract method <code>UpdatePublisher</code> that is called at the end of the pose optimization. Its implementation is highly dependent on the information that should be exchanged. In most applications, it is used to publish predicted poses. Currently, no <code>Publisher</code> is implemented.</li>
<li><b>Subscriber:</b> Is used to read data from an external source. It provides the abstract method <code>UpdateSubscriber</code> that is called before the optimization. As for the <code>Publisher</code> class, the implementation is highly dependent on the source and exchanged information. When the main method is executed, the tracker is in a defined state, without anything happening in parallel. A <code>Subscriber</code> can, therefore, not only modify pose predictions but is able to change settings or the entire configuration of referenced objects. Currently, no <code>Subscriber</code> is implemented.</li>
<li><b>Refiner:</b> References <code>Optimizer</code> objects to refine pose predictions of the corresponding kinematic structures. It thereby coordinates different methods provided by <code>Optimizer</code>, <code>Constraint</code>, <code>SoftConstraint</code>, <code>Link</code>, <code>Modality</code>, <code>ColorHistograms</code>, and <code>Renderer</code> objects. The refinement process is very similar to the <em>Tracking Step</em>. The only main difference is that methods featured in the <em>Starting Step</em> are executed each time before correspondences are calculated. It is implemented in the <a href="classm3t_1_1Refiner.html">Refiner</a> class.</li>
<li><b>Tracker:</b> References <code>Optimizer</code>, <code>Refiner</code>, <code>Publisher</code>, <code>Subscriber</code>, <code>Viewer</code>, and <code>Detector</code> objects. In addition to an orderly setup, it facilitates the entire tracking process. The <code>Tracker</code> thereby coordinates the execution of methods provided by different objects. To control the process, it provides interfaces to start the tracking, stop the tracking, and execute the detection of kinematic structures represented by an <code>Optimizer</code>. It is implemented in the <a href="classm3t_1_1Tracker.html">Tracker</a> class.</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
Example Configuration</h2>
<p>Based on those components, a tracker can be configured. An example of a tracker that tracks a kinematic structure with two bodies using information from two color cameras and one depth camera is shown in the following illustration:</p>
<div class="image">
<img src="components.png" alt=""/>
<div class="caption">
tracking process</div></div>
    <p>For each <code>Body</code> and <code>ColorCamera</code>, a <code>RegionModality</code> is configured. Similarly, each <code>Body</code> supports a <code>DepthModality</code>. To validate points, each <code>Modality</code> references a <code>SilhouetteRenderer</code> that corresponds to a <code>Camera</code>. In addition, the <code>RegionModality</code> objects 2 and 4 consider occlusions using the <code>DepthCamera</code>. For initialization, a <code>ManualDetector</code> predicts the pose of the <code>Link</code> and <code>Body</code> number 1 and uses the <code>Optimizer</code> to update the kinematic structure. Afterwards, the estimate is improved using a <code>Refiner</code>. Also, a <code>Subscriber</code> is configured that has access to all objects connected to the <code>Optimizer</code>. Finally, results are visualized using a <code>NormalViewer</code>, and pose estimates of <code>Body</code> number 2 are communicated using a <code>Publisher</code>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Usage</h1>
<p>As explained previously, <em>M3T</em> is a library that supports a wide variety of tracking scenarios. As a consequence, to start tracking, one has to first configure the tracker. For this, two options exist:</p>
<ul>
<li>One option is to use <em>C++</em> programming to set up and configure all objects according to one's scenario. An example that allows running the tracker on a sequence streamed from an AzureKinect is shown in <code>examples/run_on_camera_sequence.cpp</code>. The executable thereby takes the path to a directory and names of multiple bodies. The directory has to contain <code>Body</code> and <code>StaticDetector</code> metafiles that are called <code>&lt;BODY_NAME&gt;.yaml</code> file and <code>&lt;BODY_NAME&gt;_detector.yaml</code>. Similarly, <code>examples/run_on_recorded_sequence.cpp</code> allows to run the tracker on a sequence that was recorded using <code>record_camera_sequence.cpp</code>. The executable allows the tracking of a single body that is detected using a <code>ManualDetector</code>. It requires the metafiles for a <code>LoaderColorCamera</code>, <code>Body</code>, and <code>ManualDetector</code>, as well as the path to a temporary directory in which generated model files are stored.</li>
<li>In addition to the usage as a library in combination with <em>C++</em> programming, the tracker can also be configured using a generator function together with a YAML file that defines the overall configuration. A detailed description of how to set up the YAML file is given in the <a href="generator.html">documentation</a> or the following <a href="https://github.com/DLR-RM/3DObjectTracking/tree/master/M3T/doc/high_level/generator.md">markdown file</a>. An example that shows how to use a generator is shown in <code>examples/run_generated_tracker.cpp</code>. The executable requires a YAML file that is parsed by the <code>GenerateConfiguredTracker()</code> function to generate a <code>Tracker</code> object. The main YAML file thereby defines how individual objects are combined and allows to specify YAML metafiles for individual components that do not use default parameters. An example of a simple YAML file is given in <code>data/pen_paper_demo/conig.yaml</code>. The example can be executed using <code>examples/run_pen_paper_demo.cpp</code>. In the code, a dedicated <code>Publisher</code> class is implemented that visualizes the drawing of a stabilo pen on a paper. The example runs out of the box using the configuration and data provided in the <code>data/pen_paper_demo</code> directory. Finally, more complex examples for the configuration of kinematic structures using YAML files are provided in the <em>RTB</em> datast, which can be downloaded from <a href="https://zenodo.org/record/7548537">Zenodo</a>.</li>
</ul>
<p>In addition to constructor and setter methods, the parameters of all components can be defined using YAML metafiles. Parameter names in the YAML file are thereby defined to be equal to names used in the code. The most important metafiles and parameters are:</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Body</h3>
<div class="fragment"><div class="line">geometry_path: &quot;INFER_FROM_NAME&quot;</div>
<div class="line">geometry_unit_in_meter: 1.0</div>
<div class="line">geometry_counterclockwise: 1</div>
<div class="line">geometry_enable_culling: 1</div>
<div class="line">geometry2body_pose: !!opencv-matrix</div>
<div class="line">  rows: 4</div>
<div class="line">  cols: 4</div>
<div class="line">  dt: d</div>
<div class="line">  data: [ 1, 0, 0, 0,</div>
<div class="line">          0, 1, 0, 0,</div>
<div class="line">          0, 0, 1, -0.006,</div>
<div class="line">          0, 0, 0, 1 ]</div>
<div class="line">region_id: 50</div>
</div><!-- fragment --><ul>
<li><code>geometry_path</code>: path to wavefront obj file. Using <code>INFER_FROM_NAME</code> sets the path to <code>&lt;BODY_NAME&gt;.obj</code>.</li>
<li><code>geometry_unit_in_meter</code>: scale factor to scale the unit used in the wavefront obj file to meter.</li>
<li><code>geometry_counterclockwise</code>: true if winding order of triangles in wavefront obj is defined counter-clockwise.</li>
<li><code>geometry_enable_culling</code>: true if faces that are not facing toward the camera should be culled.</li>
<li><code>geometry2body_pose</code>: transformation that allows to set a different frame of reference for the object than defined by the wavefront obj file.</li>
<li><code>region_id</code>: value between 1 and 255 that is assigned to pixels on the body's silhouette by <code>SilhouetteRenderers</code> that render the region ID. For bodies with similar color statistics, the same value should be assigned for the validation of contour points. Note that the <code>body_id</code> is set automatically to a unique ID.</li>
</ul>
<h3><a class="anchor" id="autotoc_md11"></a>
DepthModel / RegionModel</h3>
<div class="fragment"><div class="line">model_path: &quot;INFER_FROM_NAME&quot;</div>
</div><!-- fragment --><ul>
<li><code>model_path</code>: path to .bin file where the sparse viewpoint model is stored or where it should be generated. Using <code>INFER_FROM_NAME</code> sets the path to <code>&lt;MODEL_NAME&gt;.bin</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md12"></a>
StaticDetector</h3>
<div class="fragment"><div class="line">link2world_pose: !!opencv-matrix</div>
<div class="line">  rows: 4</div>
<div class="line">  cols: 4</div>
<div class="line">  dt: d</div>
<div class="line">  data: [0.607674, 0.786584, -0.10962, -0.081876,</div>
<div class="line">          0.408914, -0.428214, -0.805868, -0.00546736,</div>
<div class="line">          -0.680823, 0.444881, -0.58186, 0.618302,</div>
<div class="line">          0, 0, 0, 1 ]</div>
</div><!-- fragment --><ul>
<li><code>link2world_pose</code>: transformation between link and world (typically camera frame) to which the link is set by the detector. If the link has a body, the corresponding <code>body2world_pose</code> is set to the same pose.</li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
ManualDetector</h3>
<div class="fragment"><div class="line">reference_points:</div>
<div class="line">  - [ -0.0332, 0.0, 0.0]</div>
<div class="line">  - [ 0.0192, -0.0332, 0.0]</div>
<div class="line">  - [ 0.0192, 0.0332, 0.0]</div>
<div class="line">  - [ 0.0, 0.0, 0.0]</div>
<div class="line">detector_image_path: &quot;./detector_image.png&quot;</div>
</div><!-- fragment --><ul>
<li><code>reference_points</code>: 3D points on the object surface given in the body frame. During manual detection, the user has to specify the corresponding 2D coordinates of those points in the image to define the object pose.</li>
<li><code>detector_image_path</code>: optional image that illustrates on which points the user has to click.</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
LoaderColorCamera / LoaderDepthCamera</h3>
<div class="fragment"><div class="line">load_directory: &quot;./&quot;</div>
<div class="line">intrinsics:</div>
<div class="line">   f_u: 638.633</div>
<div class="line">   f_v: 638.377</div>
<div class="line">   pp_x: 639.451</div>
<div class="line">   pp_y: 366.379</div>
<div class="line">   width: 1280</div>
<div class="line">   height: 720</div>
<div class="line">camera2world_pose: !!opencv-matrix</div>
<div class="line">   rows: 4</div>
<div class="line">   cols: 4</div>
<div class="line">   dt: f</div>
<div class="line">   data: [ 1, 0, 0, 0,</div>
<div class="line">            0, 1, 0, 0,</div>
<div class="line">            0, 0, 1, 0,</div>
<div class="line">            0, 0, 0, 1 ]</div>
<div class="line">depth_scale: 0.001    # only for depth camera</div>
<div class="line">image_name_pre: &quot;color_camera_image_&quot;</div>
<div class="line">load_index: 0</div>
<div class="line">n_leading_zeros: 0</div>
<div class="line">image_name_post: &quot;&quot;</div>
<div class="line">load_image_type: &quot;png&quot;</div>
</div><!-- fragment --><ul>
<li><code>load_directory</code>: directory from which images are loaded.</li>
<li><code>intrinsics</code>: intrinsics of the camera that was used to record images, with fu, fv, ppu, ppv, width, and height, respectively.</li>
<li><code>camera2world_pose</code>: fixed transformation between camera and world.</li>
<li><code>depth_scale</code>: scale with which pixel values have to be multiplied to get the depth in meter. (only required for depth cameras)</li>
<li><code>image_name_pre</code>: text at the beginning of image name, before load_index.</li>
<li><code>load_index</code>: index of the first image that is loaded.</li>
<li><code>n_leading_zeros</code>: minimum number of digits used in the image name with zero padding to reach correct number.</li>
<li><code>image_name_post</code>: text at the end of image name, after load_index.</li>
<li><code>load_image_type</code>: file format of images.</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
Link</h3>
<div class="fragment"><div class="line">free_directions: [0, 0, 1, 0, 0, 0]</div>
<div class="line">body2joint_pose: !!opencv-matrix</div>
<div class="line">  rows: 4</div>
<div class="line">  cols: 4</div>
<div class="line">  dt: d</div>
<div class="line">  data: [1, 0, 0, 0,</div>
<div class="line">          0, 1, 0, 0,</div>
<div class="line">          0, 0, 1, 0,</div>
<div class="line">          0, 0, 0, 1 ]</div>
<div class="line">joint2parent_pose: !!opencv-matrix</div>
<div class="line">  rows: 4</div>
<div class="line">  cols: 4</div>
<div class="line">  dt: d</div>
<div class="line">  data: [-1, 0, 0, 0.030601,</div>
<div class="line">          0, 1, 0, -0.006515,</div>
<div class="line">          0, 0, -1, 0,</div>
<div class="line">          0, 0, 0, 1 ]</div>
</div><!-- fragment --><ul>
<li><code>free_directions</code>: variated joint directions for x, y, and z rotation and translation, respectively.</li>
<li><code>body2joint_pose</code>: transformation between the joint and the body frame, which is referenced by this link.</li>
<li><code>joint2parent_pose</code>: transformation between the joint and the parent frame, for which this link is the child.</li>
</ul>
<h3><a class="anchor" id="autotoc_md16"></a>
Constraint</h3>
<div class="fragment"><div class="line">constraint_directions: [1, 1, 0, 1, 1, 1]</div>
<div class="line">body12joint1_pose: !!opencv-matrix</div>
<div class="line">  rows: 4</div>
<div class="line">  cols: 4</div>
<div class="line">  dt: d</div>
<div class="line">  data: [1, 0, 0, 0.030601,</div>
<div class="line">          0, 1, 0, 0.006515,</div>
<div class="line">          0, 0, 1, 0,</div>
<div class="line">          0, 0, 0, 1 ]</div>
<div class="line">body22joint2_pose: !!opencv-matrix</div>
<div class="line">  rows: 4</div>
<div class="line">  cols: 4</div>
<div class="line">  dt: d</div>
<div class="line">  data: [1, 0, 0, 0,</div>
<div class="line">          0, 1, 0, 0,</div>
<div class="line">          0, 0, 1, 0,</div>
<div class="line">          0, 0, 0, 1 ]</div>
</div><!-- fragment --><ul>
<li><code>constraint_directions</code>: constraint joint directions for x, y, and z rotation and translation, respectively.</li>
<li><code>body12joint1_pose</code>: transformation between the joint and the body frame of link 1.</li>
<li><code>body22joint2_pose</code>: transformation between the joint and the body frame of link 2.</li>
</ul>
<h3><a class="anchor" id="autotoc_md17"></a>
FocusedSilhouetteRenderer</h3>
<div class="fragment"><div class="line">id_type: 1</div>
</div><!-- fragment --><ul>
<li><code>id_type</code>: if the value is 0, body IDs are rendered into the silhouette image, and if the value is 1, region IDs are rendered.</li>
</ul>
<p>To start tracking your own objects, we recommend defining your own metafile for <code>Body</code> and <code>StaticDetector</code> objects and use the <code>examples/run_on_camera_sequence.cpp</code>. Note that depending on the parameters for the <code>RunTrackerProcess</code> function, detection and tracking will not start automatically. To start the detection, please press the <code>D</code> key on your keyboard. To start and stop the tracking, the <code>T</code> and <code>S</code> keys have to be used. To quit the application, press <code>Q</code>. If you would like to use the RealSense camera instead of the AzureKinect, please replace <code>#include &lt;<a class="el" href="azure__kinect__camera_8h_source.html">m3t/azure_kinect_camera.h</a>&gt;</code> with <code>#include &lt;<a class="el" href="realsense__camera_8h_source.html">m3t/realsense_camera.h</a>&gt;</code> and all occurrences of <code>AzureKinectColorCamera</code> and <code>AzureKinectDepthCamera</code> with <code>RealSenseColorCamera</code> and <code>RealSenseDepthCamera</code>. If you would like to use another camera than the RealSense or Azure Kinect, we encourage you to create a class similar to the <code>AzureKinectCamera</code> class in <code>src/azure_kinect_camera.cpp</code>. To use results from the tracker in your own application, you can implement your own <code>Publisher</code> class that implements the method <code>UpdatePublisher()</code>. Similarly, application-dependent <code>Subscriber</code> classes that implement the <code>UpdateSubscriber()</code> method can be created. More complex examples for the configuration of kinematic structures using YAML files are provided in the <a href="https://zenodo.org/record/7548537"><em>RTB</em> datast</a>. The dataset includes config files for each object in the directory <code>&lt;OBJECT_NAME&gt;/model/tracker_config</code>. By providing the path to <code>config.yaml</code> as an argument to <code>examples/run_generated_tracker</code>, a tracker for the respective object is created. Note that the first time it is executed, model files have to be generated, which might take some time.</p>
<p>In addition to this short overview, detailed information on all components and parameters can be found in the <a href="annotated.html">documentation</a>. To generate a tracker from a YAML file using the generator function, see the correspondinng <a href="generator.html">documentation</a> or <a href="https://github.com/DLR-RM/3DObjectTracking/tree/master/M3T/doc/high_level/generator.md">markdown file</a> for how to configure all the required components. For developers, an overview of the most important guidelines is provided in the <a href="developer.html">developer guide</a>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Evaluation</h1>
<p>The code in <code>examples/evaluate_&lt;DATASET_NAME&gt;_dataset.cpp</code> and <code>examples/parameters_study_&lt;DATASET_NAME&gt;.cpp</code> contains everything for the evaluation on the <em>RTB</em>, <em>YCB-Video</em>, <em>OPT</em>, <em>Choi</em>, and <em>RBOT</em> datasets. For the evaluation, please download the <a href="https://zenodo.org/record/7548537">RTB</a>, <a href="https://rse-lab.cs.washington.edu/projects/posecnn/">YCB-Video</a>, <a href="http://media.ee.ntu.edu.tw/research/OPT/">OPT</a>, <a href="http://people.ece.umn.edu/~cchoi/research_rgbdtracking.html">Choi</a>, and <a href="http://cvmr.info/research/RBOT/">RBOT</a> datasets and adjust the <code>dataset_directory</code> in the source code. Note that model files (e.g. 002_master_chef_can_depth_model.bin, 002_master_chef_can_region_model.bin, ...) will be created automatically and are stored in the specified <code>external_directory</code>. To reproduce evaluation results of <em>DART</em> on the <em>RTB</em> dataset, please unzip the <code>datet/rtb_poses.zip</code> file and store its content in the respective <code>external_directory</code>. For the evaluation of the <em>YCB-Video</em> dataset, please unzip <code>data/ycb-video_poses.zip</code> and, again, store its content in the corresponding <code>external_directory</code>. Also, for the evaluation of multi-region tracking, the content of the <code>data/ycb-video_multi-region_&lt;X&gt;.zip</code> files, which contain required .obj files, has to be copied into the <code>external_directory</code>. For the <em>Choi</em> dataset, the <em>Matlab</em> script in <code>examples/dataset_converter/convert_choi_dataset.m</code> has to be executed to convert .pcd files into .png images. Also, using a program such as <em>MeshLab</em>, all model files have to be converted from .ply to .obj files and stored in the folder <code>external_directory/models</code>. The <em>RTB</em>, <em>OPT</em>, and <em>RBOT</em> datasets work without any manual changes.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
References</h1>
<p>More details can be found in the following publications:</p>
<ul>
<li><b>Closing the Loop: 3D Object Tracking for Advanced Robotic Manipulation</b> <br  />
 Manuel Stoiber <br  />
 Dissertation submitted to the Technical University of Munich</li>
<li><b>A Multi-body Tracking Framework - From Rigid Objects to Kinematic Structures</b> <br  />
 Manuel Stoiber, Martin Sundermeyer, Wout Boerdijk, and Rudolph Triebel <br  />
 Submitted to IEEE Transactions on Pattern Analysis and Machine Intelligence: <a href="https://arxiv.org/abs/2208.01502">paper</a></li>
<li><b>Fusing Visual Appearance and Geometry for Multi-Modality 6DoF Object Tracking</b> <br  />
 Manuel Stoiber, Mariam Elsayed, Anne E. Reichert, Florian Steidle, Dongheui Lee, and Rudolph Triebel <br  />
 Submitted to IEEE/RSJ International Conference on Intelligent Robots 2023: <a href="https://arxiv.org/abs/2302.11458">paper</a></li>
<li><b>Iterative Corresponding Geometry: Fusing Region and Depth for Highly Efficient 3D Tracking of Textureless Objects</b> <br  />
 Manuel Stoiber, Martin Sundermeyer, and Rudolph Triebel <br  />
 IEEE/CVF Conference on Computer Vision and Pattern Recognition 2022: <a href="https://arxiv.org/abs/2203.05334">paper</a></li>
<li><b>SRT3D: A Sparse Region-Based 3D Object Tracking Approach for the Real World</b> <br  />
 Manuel Stoiber, Martin Pfanne, Klaus H. Strobl, Rudolph Triebel, and Alin Albu-Schäffer <br  />
 International Journal of Computer Vision: <a href="https://arxiv.org/abs/2110.12715">paper</a></li>
<li><b>A Sparse Gaussian Approach to Region-Based 6DoF Object Tracking</b> <br  />
 Manuel Stoiber, Martin Pfanne, Klaus H. Strobl, Rudolph Triebel, and Alin Albu-Schäffer <br  />
 [Best Paper] Asian Conference on Computer Vision 2020: <a href="https://openaccess.thecvf.com/content/ACCV2020/papers/Stoiber_A_Sparse_Gaussian_Approach_to_Region-Based_6DoF_Object_Tracking_ACCV_2020_paper.pdf">paper</a>, <a href="https://openaccess.thecvf.com/content/ACCV2020/supplemental/Stoiber_A_Sparse_Gaussian_ACCV_2020_supplemental.zip">supplementary</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.7
</small></address>
</body>
</html>
